########################################################################################################################
Analysis. Project "Problems vs. Algorithms"
########################################################################################################################

------------------------------------------------------------------------------------------------------------------------
#Problem1

    In the function sqrt_slower() loop starts when x=2 and ends when x*x=N.
    Or, in other words, it stops when x = square root of N.
    The runtime is significantly slower than implementation of sqrt() function by Newton's method
    which takes O(logN) as it was expected in the task. Here we divide N by 2 until we reach square root of N
    skipping several steps.

------------------------------------------------------------------------------------------------------------------------
#Problem2

    We are using a binary search to implement this task which takes O(logN) time.
    We divide the array on 2 parts recursively to determine which side is normally ordered,
    then use the normally ordered half to figure out which side to search to find the target.

------------------------------------------------------------------------------------------------------------------------
#Problem3

    I'm using QuickSort algorithm to sort the input array and then create a pair of numbers for result.
    QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array
    around the picked pivot.
    QuickSort is very popular because it's average time complexity is much quicker. With a good pivot the QuickSort
    would partition the array into halves which grows logarithmically with N. The average time is O(NlogN).
    When the smallest of largest element is selected as the pivot it would lead to a worst case
    time complexity of O(N^2).






