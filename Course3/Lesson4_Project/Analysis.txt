########################################################################################################################
Analysis. Project "Problems vs. Algorithms"
########################################################################################################################

------------------------------------------------------------------------------------------------------------------------
#Problem1

    In the function sqrt_slower() loop starts when x=2 and ends when x*x=N.
    Or, in other words, it stops when x = square root of N.
    The runtime is significantly slower than implementation of sqrt() function by Newton's method
    which takes O(logN) as it was expected in the task. Here we divide N by 2 until we reach square root of N
    skipping several steps.

------------------------------------------------------------------------------------------------------------------------
#Problem2

    We are using a binary search to implement this task which takes O(logN) time.
    We divide the array on 2 parts recursively to determine which side is normally ordered,
    then use the normally ordered half to figure out which side to search to find the target.

------------------------------------------------------------------------------------------------------------------------
#Problem3

    To implement the task first I need to sort the array and then create a pair of numbers to return as a result.

    In function sort_list_slower() I'm using QuickSort algorithm to sort the input array.
        QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array
        around the picked pivot.
        QuickSort is very popular because it's average time complexity is much quicker. With a good pivot the QuickSort
        would partition the array into halves which grows logarithmically with N. The average time is O(NlogN).
        When the smallest of largest element is selected as the pivot it would lead to a worst case
        time complexity of O(N^2).
    In function sort_list() I'm using HeapSort algorithm which guarantee to take O(NlogN) which is better than the
        worst case of QuickSort.
    The overall time complexity of rearrange_digits() function is O(NlogN) with HeapSort.

------------------------------------------------------------------------------------------------------------------------
#Problem4

    Only one traversal of N elements takes O(N) time. Space is O(1).

    At first, the full array is unknown. There are three indices â€“ low, mid and high.
    low_index - is a counter of zeroes in the input_list which counts from the beginning of the list,
                the zeroes will be in range input_list[0:low_index] or starting from 0 and ending at low_index-1
    mid_index - is a counter of ones in input_list which counts from the beginning of the list,
                the ones will be in range input_list[low_index:mid_index] or starting from low_index to mid_index-1
    Since we don't know the range between ones and 2s we count high_index from the end of the input_list.
    high_index - is a counter for 2s in the input_list from the end, we continue until high_index meets the mid_index

    In a swap_numbers() function I swap elements only if they are different as an optimization.




